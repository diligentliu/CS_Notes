# C++八股总结

## 1. 在 main 函数执行前后会做什么

- main 函数执行之前，主要是初始化系统的相关资源
  - 设置栈指针
  - 初始化静态变量和全局变量，即 .data 段内容
  - 将为初始化的全局变量赋值，即 .bss 段内容
  - 全局对象初始化，在 main 之前调用构造函数
  - 将 main 函数的 argc 和 argv 压栈，相当于传参
  - \_\_attribute__((constructor))，这个东西相当于一个函数，可以通过 \_\_attribute__((constructor(101))) 类似这样的声明设置优先级，优先级往往从 101 开始，0-100 是系统使用的，会在 main 函数之前执行
- main 函数执行之后
  - 全局对象的析构函数
  - 可以用 atexit 注册一个函数，会在 main 之后运行，这个注册的顺序和最后运行的顺序是相反的，他的应用场景通常是可以通过调整注册顺序析构全局变量，例如全局对象在调用析构的时候会调用全局 Log 对象打印日志输出，这时候就需要保证 Log 对象在该对象之后虚构
  - \_\_attribute__((destructor))

## 2. 结构体内存对齐问题

内存对其的细节就不再说了，主要是为了提高内存读写的效率，这里介绍两个关键字 alignas 和 alignof

- alignof 是求该类型的内存对齐方式
- alignas 是要求该类型的内存对齐的字节数，但是 alignas 存在失效的情况
  - 一是要求的内存对齐值小于自然对齐的最小单位
  - 二是使用单字节的方式对齐，这个其实和一的类别是一样的，这里单独分开了，只是想提醒一下使用 #pragma pack(1)
  - 三是通过结构体内部指定位数的情况

## 3. 指针和引用的区别

- 指针可以是一个变量，存储的是一个地址，引用跟原来的变量本质上是同一个东西，是原变量的别名
- 指针可以有多级，引用只能有一级
- 指针可以为空，引用需要在定义时初始化
- 指针可以改变指向，但是引用在初始化后不可以再更改
- sizeof 指针得到的是指针的大小，而引用是变量的大小
- 当把指针作为参数传递时，也是将实参的拷贝传给形参，两者指向的地址相同，而不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以
- 引用本质是一个指针，同样也会占 4 字节内存，指针是具体变量，需要占用存储空间

## 4. 在传递参数时，什么时候该使用指针，什么时候该使用引用

- 需要返回函数内局部变量的内存时使用指针，使用时指针传参需要开辟内存，用完要记得释放指针，不然会内存泄露，返回局部变量的引用是没有意义的；
- 对栈空间敏感，例如递归时使用引用，因为引用传递无需创建临时变量，开销更小；
- 类对象作为参数传递时使用引用，这是C++类对象传递的标准方式（这个我感觉也可以用指针传递吧）

## 5. 堆和栈的区别

1. 申请方式不同，栈由系统自动分配，堆由程序员自己申请和释放的
2. 扩展方向不同，栈是由高地址向低地址扩展的、堆是从低地址向高地址扩展的
3. 栈由操作系统管理，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片

## 6. new / delete 和 malloc / free 的异同

- 相同点
  - 都可以用于内存的动态申请 / 释放
- 不同点
  - 前者是 C++ 运算符，后者是 C/C++ 标准库函数，需要库文件支持
  - new 自动计算内存分配的大小，malloc 需要手动计算
  - new 是类型安全的，malloc 不是，需要正确指定返回的指针类型
  - new 调用 operator new 的标准库函数分配足够的空间，并调用相关对象的构造函数，delete 对指针所指向对象运行适当的析构函数；然后通过调用 operator delete 释放内存
  - new 封装了 malloc，delete 封装了 free，如果使用 free 释放 new 申请的空间，不会报错，但是只会释放内存，而不会析构对象，对于对象管理的资源可能会发生泄露或者其他未定义行为

## 7. 被 free 的内存是立即返回操作系统吗？

C/C++ 运行时会维护一个内存池，malloc 和 free 的内存首先会从内存池中取和放，被 free 的内存会首先被 ptmalloc 使用双链表保存，当用户再次进行申请内存，会尝试先从这些内存中寻找合适的返回，这样避免了频繁的系统调用，同时 ptmalloc 也负责对小块内存进行合并，防止过多的内存碎片

## 8. 宏定义和函数有什么区别

- 宏在编译的预处理阶段完成代码的替换，运行不存在函数调用，执行更快
- 宏结构没有返回值；函数具有返回值
- 宏定义没有类型检查
- 宏定义不要添加分号，替换时会影响语义

## 9. 宏定义和 typedef 区别

- typedef 主要用于定义别名
- typedef 是编译的一部分，不会像 define 一样替换
- typedef 会进行类型检查
- 对指针的操作有一些细节上的差别，例如 typedef char *p_char 和 #define p_char char* 区别，对于语句 p_char a, b; typedef 语句相当于 char *a,*b; 而 #define 语句相当于 char *a, b;

## 10. strlen 和 sizeof 的区别

- sizeof 是运算符，并不是函数，结果在编译时并非运行时获得；strlen 是库函数，针对字符串处理。

- sizeof 参数可以是任何数据的类型或数据；strlen 参数只能是字符指针且结尾是 '\0' 的字符串

- sizeof 是编译时得到的，所以不能计算动态分配存储空间的大小，例如

  `````c++
  int* ptr = (int*)malloc(10 * sizeof(int));
  size_t size = sizeof(ptr); // 这将返回指针的大小，而不是ptr指向的内存区域的大小。
  `````

## 11. 指针常量和常量指针的区别

指针常量指向一个只读变量，变量的值不可修改，但是可以更改指针的指向，写法是 int const *p 或 const int *p

常量指针是一个不能改变指针指向的指针，写法 int *const p;

## 12. 数组的 a 和 &a 有什么区别

假设数组 int a[10]; int (*p)[10] = &a; 其中

- a 是数组名，是数组首元素地址，对 a 进行 +1 操作是取下一个数组元素
- &a 是数组的指针，类型为 int (*)[10]，对其进行 +1 操作，系统会加上整个数组的偏移

## 13. C 和 C++ 的区别

- new / delete 和 malloc / free 的区别
- 字符串类
- 输入输出库
- C++ 使用比较规范的异常处理机制代替了 C 中 setjmp() 和 longjmp()
- C++ 支持重载
- C++ 新增了引用

## 14. C++ 和 Java 的区别

- Java 完全面向对象，可以说一切皆对象，C++ 不仅支持面向对象，为了兼容 C 还支持面向过程
- Java 提供了 JVM 实现了真正意义上的跨平台，只编写一次代码，可以在任何的操作系统上运行
- Java 中没有指针的概念，减少了不安全问题
- Java 使用接口代替了抽象类的概念，在实现和维护上更容易
- Java 有自己的内存回收和分配的机制，不像 C++ 一样需要收到分配和回收

## 15. C++ 中 struct 和 class 的区别

最重要的区别其实是对成员变量和成员函数的可见性，struct 默认是 public，class 默认是 private，

## 16. C++ 中 struct 和 C 的区别

- C 语言中 struct 是用户自定义数据类型（UDT），C++ 中 struct 是抽象数据类型 （ADT），支持成员函数的定义，C++ 中的 struct 能继承，可以实现多态
- C 中 struct 是没有权限的设置的，struct 中只能是一些变量的集合体，可以封装数据但不能隐藏数据，而且成员不能是函数，当然可以是函数指针，使用函数指针的方式达到封装函数的目的

## 17. define 和 const 的区别

- define 是在编译的预处理阶段起作用，而 const 是在编译运行的时候起作用
- define 只做替换，不做类型检查和计算，也不会求解，容易产生错误，const 常量有数据类型检查
- define 只是对宏进行字符串替换，在内存中会产生多份备份，const 在程序中只有一份备份，且可以执行常亮折叠，将复杂的表达式计算出结果放入常亮表

## 18. static 和 const 的具体功能

- static
  - 不考虑类的情况下
    - 隐藏。不加 static 的函数和变量具有全局可见性，加了后只能在该文件所在的编译模块中使用
    - 默认初始化为 0，包括为初始化的全局静态变量和局部静态变量，都存储在 .bss 段
    - 静态变量在函数内定义时，始终存在，且只进行一次初始化，具有记忆性，其作用范围和局部变量相同，但是函数退出后仍然存在，再次进入作用域后，这个变量依旧保持上一次的值
  - 考虑类的情况
    - static 成员变量，属于该类而非类的实例化对象。定义时会分配空间，不能在类声明中初始化，必须在类定义体外部初始化
    - static 成员函数，不具有 this 指针，无法访问类对象的非 static 成员和非 static 成员函数；不能声明为 const、虚函数和volatile；可以被非 static 成员函数访问
- const
  - 不考虑类的情况下
    - const 常量在定义时必须初始化，之后无法更改
    - const 形参可以接收 const 和非 const 的形参
  - 考虑类的情况下
    - const 成员变量，不能在类定义外初始化，只能通过拷贝构造函数初始化成员列表初始化，且必须有构造函数；不同类对其 const 值的值可以不同
    - const 成员函数，const 对象不能调用非 const 成员函数，非 const 对象都可以调用；不可以改变非 mutable 数据的值（mutable 是为了放宽 const 成员函数的修改限制，使用场景通常是标记缓存的一些结果或调用次数的变量，这些值的改变并不改变对象对于外部的逻辑状态，只是为了加速计算或方便管理）

## 19. final 和 override 关键字

- override，声明这个函数是继承后重写的函数，编译时会确认这个函数在父类中同样声明，某种意义上是为了防止手抖敲错代码的
- final，指明某个类是不希望被继承的，某个函数是不希望被重写的

## 20. 内联函数和宏定义的区别

- 在使用时，宏定义会进行简单的字符串替换（预处理阶段），内联函数可以进行参数类型检查（编译阶段），且具有返回值
- 内联函数在编译时将函数代码嵌入到目标代码中，省去函数调用的开销，可以实现重载

## 21. 如何判断大端存储还是小端存储

- 强制转换

  `````c++
  int a = 0x1234;
  char c = (char) a;
  if (c == 0x12) {
      cout << "大端存储" << endl;
  } else if (c == 0x34) {
      cout << "小端存储" << endl;
  }
  `````

- union

  `````c++
  union Union {
      int a;
      char c;
  }
  
  int main() {
      Union un;
      un.a = 0x1234;
      if (un.c == 0x12) {
          cout << "大端存储" << endl;
      } else if (un.c == 0x34) {
          cout << "小端存储" << endl;
      }
  }
  `````

## 22. volatile、mutable 和 explicit 的用法

- volatile，易变的变量，表示声明的类型变量可以被某些编译器未知的因素更改；例如操作系统、硬件或其他线程。遇到这个关键字声明的变量，编译器对访问该变量的代码不会进行优化，系统总是重新从他所在的内存读取数据，而不是读取寄存器中的备份。可以把非 volatile 数据赋值给 volatile 变量，反过来则不行
- mutable，前面说过有时候 const 声明的函数需要更改一些与对象状态关系不大的变量，使用 mutable 修饰的变量允许在 const 函数中修改
- explicit，用在构造函数上，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换
  - explicit 只能用在类内部的构造函数声明上
  - explicit 关键字作用于单个参数的构造函数
  - 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换

## 23. C++ 中的 new

- plain new，是我们经常使用的 new，他是带有异常处理的，如果空间分配失败时，抛出 std::bad_alloc 异常，而不是 NULL
- nothrow new，在空间分配失败后不抛出异常，直接返回 NULL
- placement new，允许在一块已经分配成功的内存上重新构造对象，不用担心内存分配失败的情况，因为他不负责分配内存，只会调用对象的构造函数
  - placement new 的主要用途是反复使用一块较大的动态分配的内存来构造不同类型的对象
  - placement new 构造出来的对象数组，要显示的调用他们的析构函数来销毁（析构函数并不释放内存），千万不要使用 delete，这是因为使用 placement new 构造出来的对象或对象数组大小并不一定等于原来分配的内存大小，使用 delete 会造成内存泄漏或者之后释放内存时会出现运行时错误

## 24. C++ 中的标准异常有哪些

- bad_typeid: 使用 typeid 运算符，如果其操作数是一个多态类的指针，而这个指针是一个 NULL，则会抛出这个异常
- bad_cast: 在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会抛出此异常
- bad_alloc: 在用 new 运算符进行动态内存分配时，如果没有足够的内存，抛出此异常
- out_of_range: 用 vector 或 string 的 at 成员函数根据下标访问元素时，抛出此异常

## 25. 形参和实参的区别

- 形参变量只有在被调用时才分配内存单元，在调用结束时会释放，因此形参只有在函数内部有效。函数调用结束返回主调函数后不能再使用该形参变量
- 实参可以是常亮、变量、表达式、函数等等，无论实参是何种类型，在进行函数调用时，他们都必须具有确定的值，以便把这些值传送给形参。因此应预先赋值
- 实参和形参的数量、类型、顺序应该严格一致
- 函数调用中发生的数据传送是单向的，只能把实参的值传送给形参
- 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置

## 26. 值传递、指针传递、引用传递的区别和效率

- 值传递：有一个形参想函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或是大的结构体对象，将耗费一定的时间和空间
- 指针传递：同样有个形参向函数所属的栈拷贝数据的过程，但是拷贝的数据是一个固定位 4 字节的地址
- 引用传递：同样有上述的数据拷贝过程，但是是针对地址的，相当于为该数据所在的地址起了个别名
- 效率上后两者要比第一个效率要高，一般在确定对象非空的情况下建议使用引用传递，在逻辑上更加清晰

## 27. delete p、delete[] p、allocator 都有什么作用

- 动态数组管理，new 一个数组时，[] 必须是一个整数，但不一定必须要是常亮整数，普通数组必须是一个常亮整数
- new 动态数组返回的并不是数组类型，而是一个元素类型的指针
- delete [] 时，数组中的元素按照逆序的顺序进行销毁
- new 在内存分配时有一些局限性，new 的机制是将内存分配和对象构造组合在一起，同样的，delete 也是将对象析构和内存释放组合在一起。allocator 是将这两部分分开进行，allocator 申请一部分内存，不进行初始化对象，只有在需要的时候才进行初始化操作

## 28. new 和 delete 的实现原理，delete 是如何知道释放内存的大小的？

- new 简单类型直接调用 operator new 分配内存
- 对于复杂结构，先调用 operator new 分配内存，然后在分配的内存上调用构造函数
- 对于简单类型，new [] 计算好大小后调用 operator new
- 对于复杂结构，new [] 先调用 operator new [] 分配内存，然后在内存的前四个字节写入数组大小 n，然后调用 n 次构造函数
- delete 简单类型默认只是调用 free 函数；复杂数据类型先调用析构函数再调用 operator delete
- 简单类型 delete 和 delete[] 等同
- 假设 p 指向 new[] 分配的内存，因为要用 4 字节存储数组的大小，实际分配的内存地址为 p - 4，系统记录的也是这个地址，delete[] 实际释放的就是 p - 4 指向的内存。而 delete 会直接释放 p 指向的内存，而这个内存没有被系统记录，所以会崩溃

## 29. malloc 和 free 的实现原理

- 两个函数的底层是由 brk、mmap、munmap 这些系统调用实现的
- brk 是将数据段的最高地址指针 _edata 往高地址推，mmap 是是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间，发现缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存的映射关系
- malloc 小于 128K 的内存，使用 brk 分配内存，将 _edata 往高地址推；malloc 大于128K的内存使用 mmap 分配内存，在堆和栈之间找一块空闲内存分配；brk 分配的内存需要等到高地址内存释放以后才能释放，而 mmap 分配的内存可以单独释放。当最高地址空间的空闲内存超过 128K 时，执行内存紧缩操作（trim）。在上一个步骤 free 的时候，发现最高地址空闲内存超过 128K，于是内存紧缩
- malloc 是从堆中申请内存，也就是说函数返回的指针是指向堆里面的一块内存，操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，会遍历列表，然后找到第一个空间大于所申请空间的堆节点，然后就将该节点从空闲链表中删除，并将该节点的空间分配给程序

## 30. malloc、realloc、calloc 的区别

- malloc 需要人为计算相应的 size
- calloc 不需要人为计算
- realloc 用于扩容

## 31. 类成员的初始化方式？构造函数的执行顺序？为什么使用初始化成员列表会更快？

- 赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。主要区别在于
  - 对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的
  - 列表初始化是给数据成员分配内存空间时就进行初始化，初始化这个数据成员时函数体尚未执行
- 派生类的构造函数执行顺序如下
  - 虚拟基类的构造函数（多个虚基类则按照继承的顺序执行构造函数）
  - 基类的构造函数（多个普通基类按照继承的顺序执行构造函数）
  - 类的成员对象的构造函数，按照初始化顺序
  - 派生类自己的构造函数
- 赋值初始化使用的赋值操作对于对象成员变量会产生临时的对象

## 32. 有哪些情况必须要用到成员列表初始化

- 必须使用成员列表初始化的情况有四种
  - 初始化引用成员时
  - 初始化常量成员时
  - 调用基类的构造函数
  - 调用成员类的构造函数，而它没有无参数的构造函数
- 成员初始化列表做了什么
  - 编译器会按序操作初始化列表，以适当的顺序在构造函数之前安插初始化操作，并在任何显示用户代码之前
  - list 中的初始化顺序是由类中成员变量的声明顺序决定的，而不是由初始化列表的顺序决定的

## 33. C++ 新增的 string 和 C 中的 char * 有什么区别？他是如何实现的？

- string 继承自 basic_string 其实是对 char * 进行了封装，封装的 string 包含了 char* 数组、容量、长度等等属性
- string 可以进行动态扩展，在每次扩展的时候另外申请一块员空间大小的两倍空间，然后把原字符串拷贝过去，并加上新增的内容

## 34. 什么是内存泄露，如何检测和避免

- 内存泄露通常指堆内存的泄露，堆内存是指程序从堆中分配的，大小任意的内存块，使用完必须显示的释放。
- 避免内存泄露的几种方式
  - 计数法，使用 new 或 malloc 时，计数器 +1， delete 或 free 时，计数器 -1，程序执行完检查这个数，这里类似 shared_ptr
  - 一定要将基类的析构函数声明为虚函数
  - 对象数组的释放使用 delete []
  - 有 new 就有 delete，有 malloc 就要有 free
- 检测工具
  - Linux 可以使用 Valgrind，Valgrind是一个极其强大的内存调试工具，它通过一种叫做动态二进制插装（Dynamic Binary Instrumentation, DBI）的技术来检测内存泄漏和其他几种类型的内存错误。Valgrind 工作在一个虚拟的处理器上，运行应用程序的机器代码，同时插入额外的检查和跟踪代码来分析程序的行为。下面是 Valgrind 检测内存泄漏的基本原理：
    - Valgrind 拦截所有内存分配(`malloc`, `calloc`, `new`, 等)和释放(`free`, `delete`, 等)的调用。这使得 Valgrind 能够精确地知道程序运行过程中哪些内存被分配了以及是否被适当地释放。
    - 除了跟踪内存的分配和释放，Valgrind 还跟踪程序对这些内存的访问。这允许Valgrind 检测到如使用未初始化的内存、越界访问等问题。
    - 对于每块被分配的内存，Valgrind 维护一个状态信息，标记这块内存是“活跃的”（正在被使用）、“无效的”（如已经被释放）还是“可能泄露的”（已分配但无法到达）。这些信息有助于Valgrind在程序执行完毕时分析哪些内存没有被正确释放。
    - 程序结束时，Valgrind检查所有仍然被标记为“活跃”的内存。如果某块内存在程序结束时仍被分配（即没有被释放），但程序已经没有任何方式可以访问这块内存（即没有任何指针指向这块内存），Valgrind会将其报告为“内存泄露”。
  - Windows 可以使用 CRT 库

## 35. C++ 的四种强制转换

-  static_cast，最常见的一类，主要用法如下
   -  用于类层次结构中基类和派生类之间指针或引用的转换
      -  进行上行转换（把派生类的指针或引用转换成基类）是安全的
      -  进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
   -  用于基本类型的转换
   -  把空指针转换成目标类型的空指针
   -  把任何类型的表达式转换为 void 类型
-  const_cast，提供了将常亮指针或引用转变为非常量的实现，一般不会使用
-  reinterpret_cast，改变指针或引用的类型；将指针或引用转换为一个足够长度的整型；将整数转换为指针或引用类型
-  dynamic_cast，特点如下
   -  其他三种都是编译时完成的，dynamic_cast 是运行时处理的，有类型检查
   -  不能用于基本数据类型的强制转换
   -  dynamic_cast 要求 <> 内所描述的目标类型必须为指针或引用。dynamic_cast 转换如果成功返回的是指向类的指针或引用，指针转换失败的化会返回 nullptr，引用转换失败会抛出 bad_cast y异常
   -  在类的转换时，在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。向下转换成功与否还要与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换后的对象类型一定要相同，否则转换失败。在 C++ 中，编译期的类型转换有可能会在运行时发生错误，尤其是涉及到类对象的指针或引用操作时，更容易产生错误
   -  使用 dynamic_cast 进行转换时，基类中一定要有虚函数，否则编译不通过，类中存在虚函数，就说明它有想要让基类指针或引用指向对象的情况，转换才有意义。运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中
   -  这里补充一点应用场景吧，当我们直接通过父类指针调用父类未声明的子类的成员函数，编译器会报错，因为父类指针并不知道子类特有的成员，正确的方法应该是进行 dynamic_cast （前提是父类有 virtual 函数），然后进行调用

## 36. 类如何实现只能静态分配和只能动态分配

- 只能静态分配，把new 和 delete 运算符重载为 private 属性
- 只能动态分配，把构造函数和析构函数设为 protected 属性，再用子类来动态创建

## 37. 模版类为什么声明和实现都放在一个 .h 文件中

- C++ 的编译机制是分离式编译，编译器编译一个 cpp 文件时并不知道另一个 cpp 文件的存在，也不会主动查找，会在编译过程中创建符号，将希望寄于连接器
- 但是对于模板 cpp 文件，如果当前 cpp 文件没有模板的实例化，编译器并不会进行处理，因为当前并不知道那个 typename 是什么也无法生成对应的函数，无法得知需要使用多少空间
- 所以如果将模板的声明和实现分别放在 .h 和 .cpp 文件的话，第一点的符号将寄希望于连接器，但是连接器没有在第二点中找到对应的二进制代码，这时候编译链就跑不通
- 其实也可以在模版类 cpp 文件中添加相应的模板实例化对象，这样在编译当前 cpp 文件时会生成对应的 typename 二进制代码，但是这样就丢失了模版类的意义，因为每次添加一个类型就必须在 cpp 文件中添加对应的实例化对象

## 38. cout 和 printf 的区别

- cout 是 C++ 中的标准输出流对象，属于 iostream 库的部分，支持重载运算符 <<，使得可以连续的将多种类型的数据输出到标准输出，类型安全，可以通过对运算符的重载和函数重载来实现对各种数据类型的支持，编译时检查数据类型是否支持

- printf 是 C 中的标准输出函数，定义在 stdio.h 中，他使用格式化字符串来指定后续参数的输出格式，不具备内置的类型安全，格式化字符串和后续参数之前可能会存在类型不匹配

