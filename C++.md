# C++八股总结

## 1. 在 main 函数执行前后会做什么

- main 函数执行之前，主要是初始化系统的相关资源
  - 设置栈指针
  - 初始化静态变量和全局变量，即 .data 段内容
  - 将为初始化的全局变量赋值，即 .bss 段内容
  - 全局对象初始化，在 main 之前调用构造函数
  - 将 main 函数的 argc 和 argv 压栈，相当于传参
  - \_\_attribute__((constructor))，这个东西相当于一个函数，可以通过 \_\_attribute__((constructor(101))) 类似这样的声明设置优先级，优先级往往从 101 开始，0-100 是系统使用的，会在 main 函数之前执行
- main 函数执行之后
  - 全局对象的析构函数
  - 可以用 atexit 注册一个函数，会在 main 之后运行，这个注册的顺序和最后运行的顺序是相反的，他的应用场景通常是可以通过调整注册顺序析构全局变量，例如全局对象在调用析构的时候会调用全局 Log 对象打印日志输出，这时候就需要保证 Log 对象在该对象之后虚构
  - \_\_attribute__((destructor))

## 2. 结构体内存对齐问题

内存对其的细节就不再说了，主要是为了提高内存读写的效率，这里介绍两个关键字 alignas 和 alignof

- alignof 是求该类型的内存对齐方式
- alignas 是要求该类型的内存对齐的字节数，但是 alignas 存在失效的情况
  - 一是要求的内存对齐值小于自然对齐的最小单位
  - 二是使用单字节的方式对齐，这个其实和一的类别是一样的，这里单独分开了，只是想提醒一下使用 #pragma pack(1)
  - 三是通过结构体内部指定位数的情况

## 3. 指针和引用的区别

- 指针可以是一个变量，存储的是一个地址，引用跟原来的变量本质上是同一个东西，是原变量的别名
- 指针可以有多级，引用只能有一级
- 指针可以为空，引用需要在定义时初始化
- 指针可以改变指向，但是引用在初始化后不可以再更改
- sizeof 指针得到的是指针的大小，而引用是变量的大小
- 当把指针作为参数传递时，也是将实参的拷贝传给形参，两者指向的地址相同，而不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以
- 引用本质是一个指针，同样也会占 4 字节内存，指针是具体变量，需要占用存储空间

## 4. 在传递参数时，什么时候该使用指针，什么时候该使用引用

- 需要返回函数内局部变量的内存时使用指针，使用时指针传参需要开辟内存，用完要记得释放指针，不然会内存泄露，返回局部变量的引用是没有意义的；
- 对栈空间敏感，例如递归时使用引用，因为引用传递无需创建临时变量，开销更小；
- 类对象作为参数传递时使用引用，这是C++类对象传递的标准方式（这个我感觉也可以用指针传递吧）

## 5. 堆和栈的区别

1. 申请方式不同，栈由系统自动分配，堆由程序员自己申请和释放的
2. 扩展方向不同，栈是由高地址向低地址扩展的、堆是从低地址向高地址扩展的
3. 栈由操作系统管理，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片

## 6. new / delete 和 malloc / free 的异同

- 相同点
  - 都可以用于内存的动态申请 / 释放
- 不同点
  - 前者是 C++ 运算符，后者是 C/C++ 标准库函数，需要库文件支持
  - new 自动计算内存分配的大小，malloc 需要手动计算
  - new 是类型安全的，malloc 不是，需要正确指定返回的指针类型
  - new 调用 operator new 的标准库函数分配足够的空间，并调用相关对象的构造函数，delete 对指针所指向对象运行适当的析构函数；然后通过调用 operator delete 释放内存
  - new 封装了 malloc，delete 封装了 free，如果使用 free 释放 new 申请的空间，不会报错，但是只会释放内存，而不会析构对象，对于对象管理的资源可能会发生泄露或者其他未定义行为

## 7. 被 free 的内存是立即返回操作系统吗？

C/C++ 运行时会维护一个内存池，malloc 和 free 的内存首先会从内存池中取和放，被 free 的内存会首先被 ptmalloc 使用双链表保存，当用户再次进行申请内存，会尝试先从这些内存中寻找合适的返回，这样避免了频繁的系统调用，同时 ptmalloc 也负责对小块内存进行合并，防止过多的内存碎片

## 8. 宏定义和函数有什么区别

- 宏在编译的预处理阶段完成代码的替换，运行不存在函数调用，执行更快
- 宏结构没有返回值；函数具有返回值
- 宏定义没有类型检查
- 宏定义不要添加分号，替换时会影响语义

## 9. 宏定义和 typedef 区别

- typedef 主要用于定义别名
- typedef 是编译的一部分，不会像 define 一样替换
- typedef 会进行类型检查
- 对指针的操作有一些细节上的差别，例如 typedef char *p_char 和 #define p_char char* 区别，对于语句 p_char a, b; typedef 语句相当于 char *a,*b; 而 #define 语句相当于 char *a, b;

## 10. strlen 和 sizeof 的区别

- sizeof 是运算符，并不是函数，结果在编译时并非运行时获得；strlen 是库函数，针对字符串处理。

- sizeof 参数可以是任何数据的类型或数据；strlen 参数只能是字符指针且结尾是 '\0' 的字符串

- sizeof 是编译时得到的，所以不能计算动态分配存储空间的大小，例如

  `````c++
  int* ptr = (int*)malloc(10 * sizeof(int));
  size_t size = sizeof(ptr); // 这将返回指针的大小，而不是ptr指向的内存区域的大小。
  `````

## 11. 指针常量和常量指针的区别

指针常量指向一个只读变量，变量的值不可修改，但是可以更改指针的指向，写法是 int const *p 或 const int *p

常量指针是一个不能改变指针指向的指针，写法 int *const p;

## 12. 数组的 a 和 &a 有什么区别

假设数组 int a[10]; int (*p)[10] = &a; 其中

- a 是数组名，是数组首元素地址，对 a 进行 +1 操作是取下一个数组元素
- &a 是数组的指针，类型为 int (*)[10]，对其进行 +1 操作，系统会加上整个数组的偏移

## 13. C 和 C++ 的区别

- new / delete 和 malloc / free 的区别
- 字符串类
- 输入输出库
- C++ 使用比较规范的异常处理机制代替了 C 中 setjmp() 和 longjmp()
- C++ 支持重载
- C++ 新增了引用

## 14. C++ 和 Java 的区别

- Java 完全面向对象，可以说一切皆对象，C++ 不仅支持面向对象，为了兼容 C 还支持面向过程
- Java 提供了 JVM 实现了真正意义上的跨平台，只编写一次代码，可以在任何的操作系统上运行
- Java 中没有指针的概念，减少了不安全问题
- Java 使用接口代替了抽象类的概念，在实现和维护上更容易
- Java 有自己的内存回收和分配的机制，不像 C++ 一样需要收到分配和回收

## 15. C++ 中 struct 和 class 的区别

最重要的区别其实是对成员变量和成员函数的可见性，struct 默认是 public，class 默认是 private，

## 16. C++ 中 struct 和 C 的区别

- C 语言中 struct 是用户自定义数据类型（UDT），C++ 中 struct 是抽象数据类型 （ADT），支持成员函数的定义，C++ 中的 struct 能继承，可以实现多态
- C 中 struct 是没有权限的设置的，struct 中只能是一些变量的集合体，可以封装数据但不能隐藏数据，而且成员不能是函数，当然可以是函数指针，使用函数指针的方式达到封装函数的目的

## 17. define 和 const 的区别

- define 是在编译的预处理阶段起作用，而 const 是在编译运行的时候起作用
- define 只做替换，不做类型检查和计算，也不会求解，容易产生错误，const 常量有数据类型检查
- define 只是对宏进行字符串替换，在内存中会产生多份备份，const 在程序中只有一份备份，且可以执行常亮折叠，将复杂的表达式计算出结果放入常亮表

## 18. static 和 const 的具体功能

- static
  - 不考虑类的情况下
    - 隐藏。不加 static 的函数和变量具有全局可见性，加了后只能在该文件所在的编译模块中使用
    - 默认初始化为 0，包括为初始化的全局静态变量和局部静态变量，都存储在 .bss 段
    - 静态变量在函数内定义时，始终存在，且只进行一次初始化，具有记忆性，其作用范围和局部变量相同，但是函数退出后仍然存在，再次进入作用域后，这个变量依旧保持上一次的值
  - 考虑类的情况
    - static 成员变量，属于该类而非类的实例化对象。定义时会分配空间，不能在类声明中初始化，必须在类定义体外部初始化
    - static 成员函数，不具有 this 指针，无法访问类对象的非 static 成员和非 static 成员函数；不能声明为 const、虚函数和volatile；可以被非 static 成员函数访问
- const
  - 不考虑类的情况下
    - const 常量在定义时必须初始化，之后无法更改
    - const 形参可以接收 const 和非 const 的形参
  - 考虑类的情况下
    - const 成员变量，不能在类定义外初始化，只能通过拷贝构造函数初始化成员列表初始化，且必须有构造函数；不同类对其 const 值的值可以不同
    - const 成员函数，const 对象不能调用非 const 成员函数，非 const 对象都可以调用；不可以改变非 mutable 数据的值（mutable 是为了放宽 const 成员函数的修改限制，使用场景通常是标记缓存的一些结果或调用次数的变量，这些值的改变并不改变对象对于外部的逻辑状态，只是为了加速计算或方便管理）

## 19. final 和 override 关键字

- override，声明这个函数是继承后重写的函数，编译时会确认这个函数在父类中同样声明，某种意义上是为了防止手抖敲错代码的
- final，指明某个类是不希望被继承的，某个函数是不希望被重写的

## 20. 内联函数和宏定义的区别

- 在使用时，宏定义会进行简单的字符串替换（预处理阶段），内联函数可以进行参数类型检查（编译阶段），且具有返回值
- 内联函数在编译时将函数代码嵌入到目标代码中，省去函数调用的开销，可以实现重载

## 21. 如何判断大端存储还是小端存储

- 强制转换

  `````c++
  int a = 0x1234;
  char c = (char) a;
  if (c == 0x12) {
      cout << "大端存储" << endl;
  } else if (c == 0x34) {
      cout << "小端存储" << endl;
  }
  `````

- union

  `````c++
  union Union {
      int a;
      char c;
  }
  
  int main() {
      Union un;
      un.a = 0x1234;
      if (un.c == 0x12) {
          cout << "大端存储" << endl;
      } else if (un.c == 0x34) {
          cout << "小端存储" << endl;
      }
  }
  `````

## 22. volatile、mutable 和 explicit 的用法

- volatile，易变的变量，表示声明的类型变量可以被某些编译器未知的因素更改；例如操作系统、硬件或其他线程。遇到这个关键字声明的变量，编译器对访问该变量的代码不会进行优化，系统总是重新从他所在的内存读取数据，而不是读取寄存器中的备份。可以把非 volatile 数据赋值给 volatile 变量，反过来则不行
- mutable，前面说过有时候 const 声明的函数需要更改一些与对象状态关系不大的变量，使用 mutable 修饰的变量允许在 const 函数中修改
- explicit，用在构造函数上，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换
  - explicit 只能用在类内部的构造函数声明上
  - explicit 关键字作用于单个参数的构造函数
  - 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换

## 23. C++ 中的 new

- plain new，是我们经常使用的 new，他是带有异常处理的，如果空间分配失败时，抛出 std::bad_alloc 异常，而不是 NULL
- nothrow new，在空间分配失败后不抛出异常，直接返回 NULL
- placement new，允许在一块已经分配成功的内存上重新构造对象，不用担心内存分配失败的情况，因为他不负责分配内存，只会调用对象的构造函数
  - placement new 的主要用途是反复使用一块较大的动态分配的内存来构造不同类型的对象
  - placement new 构造出来的对象数组，要显示的调用他们的析构函数来销毁（析构函数并不释放内存），千万不要使用 delete，这是因为使用 placement new 构造出来的对象或对象数组大小并不一定等于原来分配的内存大小，使用 delete 会造成内存泄漏或者之后释放内存时会出现运行时错误

## 24. C++ 中的标准异常有哪些

- bad_typeid: 使用 typeid 运算符，如果其操作数是一个多态类的指针，而这个指针是一个 NULL，则会抛出这个异常
- bad_cast: 在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会抛出此异常
- bad_alloc: 在用 new 运算符进行动态内存分配时，如果没有足够的内存，抛出此异常
- out_of_range: 用 vector 或 string 的 at 成员函数根据下标访问元素时，抛出此异常

## 25. 形参和实参的区别

- 形参变量只有在被调用时才分配内存单元，在调用结束时会释放，因此形参只有在函数内部有效。函数调用结束返回主调函数后不能再使用该形参变量
- 实参可以是常亮、变量、表达式、函数等等，无论实参是何种类型，在进行函数调用时，他们都必须具有确定的值，以便把这些值传送给形参。因此应预先赋值
- 实参和形参的数量、类型、顺序应该严格一致
- 函数调用中发生的数据传送是单向的，只能把实参的值传送给形参
- 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置

## 26. 值传递、指针传递、引用传递的区别和效率

- 值传递：有一个形参想函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或是大的结构体对象，将耗费一定的时间和空间
- 指针传递：同样有个形参向函数所属的栈拷贝数据的过程，但是拷贝的数据是一个固定位 4 字节的地址
- 引用传递：同样有上述的数据拷贝过程，但是是针对地址的，相当于为该数据所在的地址起了个别名
- 效率上后两者要比第一个效率要高，一般在确定对象非空的情况下建议使用引用传递，在逻辑上更加清晰

## 27. delete p、delete[] p、allocator 都有什么作用

- 动态数组管理，new 一个数组时，[] 必须是一个整数，但不一定必须要是常亮整数，普通数组必须是一个常亮整数
- new 动态数组返回的并不是数组类型，而是一个元素类型的指针
- delete [] 时，数组中的元素按照逆序的顺序进行销毁
- new 在内存分配时有一些局限性，new 的机制是将内存分配和对象构造组合在一起，同样的，delete 也是将对象析构和内存释放组合在一起。allocator 是将这两部分分开进行，allocator 申请一部分内存，不进行初始化对象，只有在需要的时候才进行初始化操作

## 28. new 和 delete 的实现原理，delete 是如何知道释放内存的大小的？

- new 简单类型直接调用 operator new 分配内存
- 对于复杂结构，先调用 operator new 分配内存，然后在分配的内存上调用构造函数
- 对于简单类型，new [] 计算好大小后调用 operator new
- 对于复杂结构，new [] 先调用 operator new [] 分配内存，然后在内存的前四个字节写入数组大小 n，然后调用 n 次构造函数
- delete 简单类型默认只是调用 free 函数；复杂数据类型先调用析构函数再调用 operator delete
- 简单类型 delete 和 delete[] 等同
- 假设 p 指向 new[] 分配的内存，因为要用 4 字节存储数组的大小，实际分配的内存地址为 p - 4，系统记录的也是这个地址，delete[] 实际释放的就是 p - 4 指向的内存。而 delete 会直接释放 p 指向的内存，而这个内存没有被系统记录，所以会崩溃

## 29. malloc 和 free 的实现原理

- 两个函数的底层是由 brk、mmap、munmap 这些系统调用实现的
- brk 是将数据段的最高地址指针 _edata 往高地址推，mmap 是是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间，发现缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存的映射关系
- malloc 小于 128K 的内存，使用 brk 分配内存，将 _edata 往高地址推；malloc 大于128K的内存使用 mmap 分配内存，在堆和栈之间找一块空闲内存分配；brk 分配的内存需要等到高地址内存释放以后才能释放，而 mmap 分配的内存可以单独释放。当最高地址空间的空闲内存超过 128K 时，执行内存紧缩操作（trim）。在上一个步骤 free 的时候，发现最高地址空闲内存超过 128K，于是内存紧缩
- malloc 是从堆中申请内存，也就是说函数返回的指针是指向堆里面的一块内存，操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，会遍历列表，然后找到第一个空间大于所申请空间的堆节点，然后就将该节点从空闲链表中删除，并将该节点的空间分配给程序

## 30. malloc、realloc、calloc 的区别

- malloc 需要人为计算相应的 size
- calloc 不需要人为计算
- realloc 用于扩容

## 31. 类成员的初始化方式？构造函数的执行顺序？为什么使用初始化成员列表会更快？

- 赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。主要区别在于
  - 对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的
  - 列表初始化是给数据成员分配内存空间时就进行初始化，初始化这个数据成员时函数体尚未执行
- 派生类的构造函数执行顺序如下
  - 虚拟基类的构造函数（多个虚基类则按照继承的顺序执行构造函数）
  - 基类的构造函数（多个普通基类按照继承的顺序执行构造函数）
  - 类的成员对象的构造函数，按照初始化顺序
  - 派生类自己的构造函数
- 赋值初始化使用的赋值操作对于对象成员变量会产生临时的对象

## 32. 有哪些情况必须要用到成员列表初始化

- 必须使用成员列表初始化的情况有四种
  - 初始化引用成员时
  - 初始化常量成员时
  - 调用基类的构造函数
  - 调用成员类的构造函数，而它没有无参数的构造函数
- 成员初始化列表做了什么
  - 编译器会按序操作初始化列表，以适当的顺序在构造函数之前安插初始化操作，并在任何显示用户代码之前
  - list 中的初始化顺序是由类中成员变量的声明顺序决定的，而不是由初始化列表的顺序决定的

## 33. C++ 新增的 string 和 C 中的 char * 有什么区别？他是如何实现的？

- string 继承自 basic_string 其实是对 char * 进行了封装，封装的 string 包含了 char* 数组、容量、长度等等属性
- string 可以进行动态扩展，在每次扩展的时候另外申请一块员空间大小的两倍空间，然后把原字符串拷贝过去，并加上新增的内容

## 34. 什么是内存泄露，如何检测和避免

- 内存泄露通常指堆内存的泄露，堆内存是指程序从堆中分配的，大小任意的内存块，使用完必须显示的释放。
- 避免内存泄露的几种方式
  - 计数法，使用 new 或 malloc 时，计数器 +1， delete 或 free 时，计数器 -1，程序执行完检查这个数，这里类似 shared_ptr
  - 一定要将基类的析构函数声明为虚函数
  - 对象数组的释放使用 delete []
  - 有 new 就有 delete，有 malloc 就要有 free
- 检测工具
  - Linux 可以使用 Valgrind，Valgrind是一个极其强大的内存调试工具，它通过一种叫做动态二进制插装（Dynamic Binary Instrumentation, DBI）的技术来检测内存泄漏和其他几种类型的内存错误。Valgrind 工作在一个虚拟的处理器上，运行应用程序的机器代码，同时插入额外的检查和跟踪代码来分析程序的行为。下面是 Valgrind 检测内存泄漏的基本原理：
    - Valgrind 拦截所有内存分配(`malloc`, `calloc`, `new`, 等)和释放(`free`, `delete`, 等)的调用。这使得 Valgrind 能够精确地知道程序运行过程中哪些内存被分配了以及是否被适当地释放。
    - 除了跟踪内存的分配和释放，Valgrind 还跟踪程序对这些内存的访问。这允许Valgrind 检测到如使用未初始化的内存、越界访问等问题。
    - 对于每块被分配的内存，Valgrind 维护一个状态信息，标记这块内存是“活跃的”（正在被使用）、“无效的”（如已经被释放）还是“可能泄露的”（已分配但无法到达）。这些信息有助于Valgrind在程序执行完毕时分析哪些内存没有被正确释放。
    - 程序结束时，Valgrind检查所有仍然被标记为“活跃”的内存。如果某块内存在程序结束时仍被分配（即没有被释放），但程序已经没有任何方式可以访问这块内存（即没有任何指针指向这块内存），Valgrind会将其报告为“内存泄露”。
  - Windows 可以使用 CRT 库

## 35. C++ 的四种强制转换

-  static_cast，最常见的一类，主要用法如下
   -  用于类层次结构中基类和派生类之间指针或引用的转换
      -  进行上行转换（把派生类的指针或引用转换成基类）是安全的
      -  进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
   -  用于基本类型的转换
   -  把空指针转换成目标类型的空指针
   -  把任何类型的表达式转换为 void 类型
-  const_cast，提供了将常亮指针或引用转变为非常量的实现，一般不会使用
-  reinterpret_cast，改变指针或引用的类型；将指针或引用转换为一个足够长度的整型；将整数转换为指针或引用类型
-  dynamic_cast，特点如下
   -  其他三种都是编译时完成的，dynamic_cast 是运行时处理的，有类型检查
   -  不能用于基本数据类型的强制转换
   -  dynamic_cast 要求 <> 内所描述的目标类型必须为指针或引用。dynamic_cast 转换如果成功返回的是指向类的指针或引用，指针转换失败的化会返回 nullptr，引用转换失败会抛出 bad_cast y异常
   -  在类的转换时，在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。向下转换成功与否还要与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换后的对象类型一定要相同，否则转换失败。在 C++ 中，编译期的类型转换有可能会在运行时发生错误，尤其是涉及到类对象的指针或引用操作时，更容易产生错误
   -  使用 dynamic_cast 进行转换时，基类中一定要有虚函数，否则编译不通过，类中存在虚函数，就说明它有想要让基类指针或引用指向对象的情况，转换才有意义。运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中
   -  这里补充一点应用场景吧，当我们直接通过父类指针调用父类未声明的子类的成员函数，编译器会报错，因为父类指针并不知道子类特有的成员，正确的方法应该是进行 dynamic_cast （前提是父类有 virtual 函数），然后进行调用

## 36. 类如何实现只能静态分配和只能动态分配

- 只能静态分配，把new 和 delete 运算符重载为 private 属性
- 只能动态分配，把构造函数和析构函数设为 protected 属性，再用子类来动态创建

## 37. 模版类为什么声明和实现都放在一个 .h 文件中

- C++ 的编译机制是分离式编译，编译器编译一个 cpp 文件时并不知道另一个 cpp 文件的存在，也不会主动查找，会在编译过程中创建符号，将希望寄于连接器
- 但是对于模板 cpp 文件，如果当前 cpp 文件没有模板的实例化，编译器并不会进行处理，因为当前并不知道那个 typename 是什么也无法生成对应的函数，无法得知需要使用多少空间
- 所以如果将模板的声明和实现分别放在 .h 和 .cpp 文件的话，第一点的符号将寄希望于连接器，但是连接器没有在第二点中找到对应的二进制代码，这时候编译链就跑不通
- 其实也可以在模版类 cpp 文件中添加相应的模板实例化对象，这样在编译当前 cpp 文件时会生成对应的 typename 二进制代码，但是这样就丢失了模版类的意义，因为每次添加一个类型就必须在 cpp 文件中添加对应的实例化对象

## 38. cout 和 printf 的区别

- cout 是 C++ 中的标准输出流对象，属于 iostream 库的部分，支持重载运算符 <<，使得可以连续的将多种类型的数据输出到标准输出，类型安全，可以通过对运算符的重载和函数重载来实现对各种数据类型的支持，编译时检查数据类型是否支持

- printf 是 C 中的标准输出函数，定义在 stdio.h 中，他使用格式化字符串来指定后续参数的输出格式，不具备内置的类型安全，格式化字符串和后续参数之前可能会存在类型不匹配

## 39. 成员函数里 memset(this, 0, sizeof(*this)) 会发生什么

- 类中所有成员置为 0
- 但是在某些情况下使用会出现问题
  - 类中含有虚函数表，这么做会破坏虚函数表
  - 类中含有其他的对象

## 40. C++ 的执行流程

- 预编译
  - 删除所有的 #define，展开所有的宏定义
  - 处理条件编译指令
  - 处理 #include ，将文件内容替换到它的未知，这个过程是递归进行的，文件中包含其他的文件
  - 删除所有的注释
  - 保留所有的 #pragma 编译器指令
  - 添加行号和文件标识，这部分生成调试信息、编译错误、警告需要使用
- 编译，生成汇编代码
- 汇编，将汇编代码转变为机器可执行的指令（机器码）。根据汇编指令和机器指令的对照表一一翻译
- 链接，将不同的源文件产生的目标文件进行链接，形成一个可执行的程序
  - 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把他们和应用程序的其他模块组合起来创建最终的可执行文件。
  - 空间浪费
  - 更新困难
  - 运行速度快
- 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
  - 共享库
  - 更新方便
  - 性能损耗

## 41. 使用 C 语言实现 C++ 多态

```c++
typedef void (*FUNC)();

struct A {
    FUNC func;
    int a;
};

struct B {
    struct A a;
    int b;
};

void func_A() {
    cout << "FUNC A" << endl;
}

void func_B() {
    cout << "FUNC B" << endl;
}

void test() {
    struct A a_struct;
    struct B b_struct;
    a_struct.func = func_A;
    b_struct.a.func = func_B;

    struct A *p_A = &a_struct;
    p_A->func();
    struct A *p_A_2 = (struct A *) (&b_struct);
    p_A_2->func();
}
```

## 42. 类的 this 指针

- this 指向对象的首地址
- this 只能在成员函数中使用，在全局函数、静态函数中不能用 this
- this 的存储位置会因为编译器不同而不同，可能会在栈、寄存器、甚至全局变量。在汇编中会有三种出现情况：立即数、寄存器值、内存变量值，例如 VC 是通过 eax 寄存器传递 this 参数的
- this 在成员函数的开始前构造，在成员函数的结束后清除

## 43. 如果调用 delete this 会发生什么

在类的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递 this 指针，让成员函数知道是哪个对象调用他，当调用 delete this 时，类对象的内存空间被释放。在这时候进行任何的函数调用，如果不涉及类的数据成员和虚函数表指针，可以正常运行，但是如果涉及到 this 指针，会出现不可预期的问题

## 44. 为什么是不可预期的问题？

delete this 后释放了类对象的内存空间，这部分空间不再属于这个进程，但是由于内存池的存在，并没有被操作系统收回，仍然可以被访问，但是这里的数据又没有意义，当获取数据成员时，可能得到的是一个随机的数，访问虚函数表时，指针可能无效也可以转到未知的区域

## 45. 如果在类的析构函数中调用 delete this 函数，会发生什么？

会导致堆栈溢出。delete 的本质是调用析构函数，然后释放内存。这里就存在递归调用的问题，会出现无线递归，导致堆栈溢出

## 46. C++ 11 有什么新特性？

- nullptr 代替 NULL
- 引入了 auto 和 decltype 实现类型推导
- 引入了基于范围的 for 循环 for (int i : nums) {}
- 类和结构体中的列表初始化，可以防止隐式的类型窄化
- lambda 类型窄化
- std::forward_list 单向链表
- 右值引用和 move 语义
- ......

## 47. C++ 中 NULL 和 nullptr 的区别

在 C 中 NULL 是 (void *) 0，但是在 C++ 中 NULL 是 0，这样会在函数重载并调用 NULL 的时候出现多匹配的错误，于是 C++ 通过模板类的方式重定义了 nullptr，使 nullptr 能够转为对应类型的空指针

## 48. 智能指针

- 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄露，动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源

- shared_ptr

  ```c++
  template<typename T>
  class Shared_Ptr {
  private:
  	T *_ptr;
  	int *_count;
  public:
  	Shared_Ptr(T* ptr = NULL) : _ptr(ptr), _count(new int(1)) {}
  	Shared_Ptr(const Shared_Ptr& s) : _ptr(s._ptr), _count(s._count) {
  		++(*_count);
  	}
  	Shared_Ptr<T> &operator=(const Shared_Ptr& s) {
  		if (&s != this) {
  			if (--(*(this->_count)) == 0) {
  				delete this->_ptr;
  				delete this->_count;
  			}
  			_ptr = s._ptr;
  			_count = s._count;
  			++(*_count);
  		}
  		return *(this);
  	}
  	T& operator*() {
  		return *_ptr;
  	}
  	T* operator->() {
  		return _ptr;
  	}
  	~Shared_Ptr() {
  		--(*_count);
  		if (*_count == 0) {
  			delete _ptr;
  			delete _count;
  			_ptr = NULL;
  			_count = NULL;
  		}
  	}
  };
  ```

- unique_ptr

  ```c++
  template<typename T>
  class Unique_Ptr {
  private:
  	T *_ptr;
  public:
  	explicit Unique_Ptr(T *ptr = nullptr) : _ptr(ptr) {}
  	Unique_Ptr(const Unique_Ptr &) = delete;
  	Unique_Ptr &operator=(const Unique_Ptr &) = delete;
  	Unique_Ptr(Unique_Ptr &&other) : _ptr(other._ptr) {
  		other._ptr = nullopt;
  	}
  	Unique_Ptr &operator=(Unique_Ptr &&other) {
  		if (this != &other) {
  			delete _ptr;
  			_ptr = other._ptr;
  			other._ptr = nullptr;
  		}
  		return *this;
  	}
  	T& operator*() {
  		return *_ptr;
  	}
  	T* operator->() {
  		return _ptr;
  	}
  	T* get() {
  		return _ptr;
  	}
  	T* release() {
  		T *temp = _ptr;
  		_ptr = nullptr;
  		return temp;
  	}
  	void reset(T *p = nullptr) {
  		T *old = _ptr;
  		_ptr = p;
  		delete old;
  	}
  	~Unique_Ptr() {
  		delete _ptr;
  	}
  };
  ```

- weak_ptr，为了解决 shared_ptr 出现的环形引用问题，是为了配合 shared_ptr 引入的，使用前应该使用 lock 检查是否有效

- auto_ptr，已废弃，有拷贝语义，可能使一个对象被析构两次

## 49. C++ 哈希表的扩容机制

- 有一个负载因子的概念，负载因子等于哈希表中元素数与哈希桶数量的比值
- 当尝试插入一个新的元素使负载因子超过其最大负载因子哈希表会进行扩容
- 扩容的过程：
  - 增加桶的数量：通常使桶的数量加倍
  - 重新哈希
  - 复制或移动元素

## 50. STL 的两级空间配置器

- 一级配置器：实际上就是 malloc、free、realloc 等函数执行的内存配置，当分配大于 128 字节的空间时，直接用一级配置器分配内存
- 二级配置器
  - 维护 16 条链表，最小为 8 字节，以 8 字节递增，最大 8 * 16 = 128 字节，传入一个字节参数，表示你需要多大的内存，链表数组将找到第一个符合大小的索引，在找到索引后，会查看当前指向的链表 free_list 是否为空，如果不为空分配这个链表，从对应的 free_list中拔出，将指针后移一位
  - 如果对应的 free_list 为空，先看内存池中是否为空，如果不空
    - 检验他剩余空间是否够 20 个节点大小，若足够则直接从内存池中拿出 20 个节点大小空间，将其中一个分配给用户，另外 19 个挂载到 free_list 末端
    - 如果不够 20 个，则看他能否满足一个节点，分配给用户，剩余的内存池尽可能多的挂载到 free_list 末端
    - 如果不够一个节点将内存池剩余的空间挂载到能挂载的节点，然后再给内存池申请内存
  - 如果内存池为空，二级配置器会使用 malloc 从堆上申请内存，大概会申请 20 块所需内存的大小，一半拿来用，一半放到内存池中
  - malloc 失败，说明堆上已经没有内存了，此时二级配置器会去更大的索引位置去搜索，从比它所需节点空间更大的 free_list 找一个节点使用，如果没找到，就去调用一级适配器
- 释放时若释放的空间大于 128 字节，则会调用一级配置器，否则将内存块挂上自由链表
- 在增加效率的同时带来了一些问题：
  - 因为 free_list 的大小都是八的倍数，不可避免的带来了一些内部碎片的问题
  - 在程序执行的过程中，二级配置器将申请的内存一块一块的挂载到自由链表上，不会返还给操作系统，这些内存块在程序运行结束才会被释放内存，随着不断开辟小内存，堆上的空闲大小越来越小，可能会导致开辟大块内存失败，而且当前进程一直占用也会使其他进程使用不了。

## 51. vector 如何释放空间

由于 vector 只增不减，比如你首先分配了 10000 个字节，然后 erase 掉后面 9999 个，留下一个有效元素，但是内存占用仍然为 10000 个。所有的内存空间在 vector 析构时才被回收，即使调用 clear 仍然如此

如果需要动态空间缩小，可以考虑使用 deque。如果 vector 可以使用 swap 释放内存

```c++
vector(Vec).swap(Vec);
vector().swap(Vec);
```

## 52. erase 的迭代器失效问题

- 数组式容器，删除对应的迭代器后会使之后的迭代器都失效，不能使用 erase(it++) 的方式，但是 erase 的返回值是下一个有效的迭代器
- 关联容器，只失效被删除的迭代器

## 53. map 中 [] 与 find 的区别？

- map 的下标运算符的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个 map
- map 的 find 函数在找到后会返回对应的迭代器；如果不存在这个关键码，就返回尾迭代器

## 54. deque

- deque 没有容量的概念，他是动态的以分段连续空间组合而成，随时可以添加一段新的空间并链接起来，有点像数组的链表
- deque 是双向开口的连续线性空间，可以在头尾两段进行插入和删除操作，时间复杂度为 O(1) 

## 55. stl 中的 allocator、deallocator

allocator、deallocator 相当于做了一个一级配置器和二级配置器的空间入口判断

## 56. 什么时候析构函数不需要写成虚函数——奇异的递归模板模式

CRTP 模板中不需要声明为虚函数：

```c++
template <typename T>
class Base {
public:
	void func() {
		T& derived = static_cast<T&>(*this);
		derived.func();
	}
};

class Derived_1 : public Base<Derived_1> {
public:
	void func() {
		std::cout << "Derived_1 class" << std::endl;
	}
};

class Derived_2 : public Base<Derived_2> {
public:
	void func() {
		std::cout << "Derived_2 class" << std::endl;
	}
};

int main() {
	Base<Derived_1> *d1 = new Derived_1();
	Base<Derived_2> *d2 = new Derived_2();
	d1->func();
	d2->func();
	delete d1;
	delete d2;
	return 0;
}
```

## 57. inline 关键字可否将构造函数、析构函数、虚函数声明为内联函数

首先，将这些函数声明为内联函数，在语法上没有错误。因为 inline 同 register 一样，只是个建议，编译器并不一定真正的内联。

register 关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率

构造函数和析构函数声明为内联函数是没有意义的

《Effective C++》中所阐述的是：将构造函数和析构函数声明为 inline 是没有什么意义的，即编译器并不真正对声明为 inline 的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数 / 析构函数并不像看上去的那么精简。其次，class中的函数默认是 inline 型的，编译器也只是有选择性的 inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

将虚函数声明为inline，要分情况讨论

有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开

综上，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。

## 58. 构造函数和析构函数中可以调用虚函数吗？

- 语法上，没有问题
- 效果上，达不到应该有的目的，派生类对象在进入基类的构造函数和析构函数时，对象类型变成了基类类型，而不是派生类类型。

## 59. 虚继承

虚继承出现在菱形继承或者说钻石继承的情况下，因为这种继承方式内部会继承多个基类，虚继承的情况下，无论基类被继承多少次，只会存在一个实体
