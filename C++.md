# C++八股总结

## 1. 在 main 函数执行前后会做什么

- main 函数执行之前，主要是初始化系统的相关资源
  - 设置栈指针
  - 初始化静态变量和全局变量，即 .data 段内容
  - 将为初始化的全局变量赋值，即 .bss 段内容
  - 全局对象初始化，在 main 之前调用构造函数
  - 将 main 函数的 argc 和 argv 压栈，相当于传参
  - \__attribute__((constructor))，这个东西相当于一个函数，可以通过 \__attribute__((constructor(101))) 类似这样的声明设置优先级，优先级往往从 101 开始，0-100 是系统使用的，会在 main 函数之前执行
- main 函数执行之后
  - 全局对象的析构函数
  - 可以用 atexit 注册一个函数，会在 main 之后运行，这个注册的顺序和最后运行的顺序是相反的，他的应用场景通常是可以通过调整注册顺序析构全局变量，例如全局对象在调用析构的时候会调用全局 Log 对象打印日志输出，这时候就需要保证 Log 对象在该对象之后虚构
  - \__attribute__((destructor))

## 2. 结构体内存对齐问题

内存对其的细节就不再说了，主要是为了提高内存读写的效率，这里介绍两个关键字 alignas 和 alignof

- alignof 是求该类型的内存对齐方式
- alignas 是要求该类型的内存对齐的字节数，但是 alignas 存在失效的情况
  - 一是要求的内存对齐值小于自然对齐的最小单位
  - 二是使用单字节的方式对齐，这个其实和一的类别是一样的，这里单独分开了，只是想介绍一下 #pragma pack(1)
  - 三是通过结构体内部指定位数的情况

## 3. 指针和引用的区别

- 指针可以是一个变量，存储的是一个地址，引用跟原来的变量本质上是同一个东西，是原变量的别名
- 指针可以有多级，引用只能有一级
- 指针可以为空，引用需要在定义时初始化
- 指针可以改变指向，但是引用在初始化后不可以再更改
- sizeof 指针得到的是指针的大小，而引用是变量的大小
- 当把指针作为参数传递时，也是将实参的拷贝传给形参，两者指向的地址相同，而不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以
- 引用本质是一个指针，同样也会占 4 字节内存，指针是具体变量，需要占用存储空间

## 4. 在传递参数时，什么时候该使用指针，什么时候该使用引用

- 需要返回函数内局部变量的内存时使用指针，使用时指针传参需要开辟内存，用完要记得释放指针，不然会内存泄露，返回局部变量的引用是没有意义的；
- 对栈空间敏感，例如递归时使用引用，因为引用传递无需创建临时变量，开销更小；
- 类对象作为参数传递时使用引用，这是C++类对象传递的标准方式（这个我感觉也可以用指针传递吧）

## 5. 堆和栈的区别

1. 申请方式不同，栈由系统自动分配，堆由程序员自己申请和释放的
2. 扩展方向不同，栈是由高地址向低地址扩展的、堆是从低地址向高地址扩展的
3. 栈由操作系统管理，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片

## 6. new / delete 和 malloc / free 的异同

- 相同点
  - 都可以用于内存的动态申请 / 释放
- 不同点
  - 前者是 C++ 运算符，后者是 C/C++ 标准库函数，需要库文件支持
  - new 自动计算内存分配的大小，malloc 需要手动计算
  - new 是类型安全的，malloc 不是，需要正确指定返回的指针类型
  - new 调用 operator new 的标准库函数分配足够的空间，并调用相关对象的构造函数，delete 对指针所指向对象运行适当的析构函数；然后通过调用 operator delete 释放内存
  - new 封装了 malloc，delete 封装了 free，如果使用 free 释放 new 申请的空间，不会报错，但是只会释放内存，而不会析构对象，对于对象管理的资源可能会发生泄露或者其他未定义行为

## 7. 被 free 的内存是立即返回操作系统吗？

C/C++ 运行时会维护一个内存池，malloc 和 free 的内存首先会从内存池中取和放，被 free 的内存会首先被 ptmalloc 使用双链表保存，当用户再次进行申请内存，会尝试先从这些内存中寻找合适的返回，这样避免了频繁的系统调用，同时 ptmalloc 也负责对小块内存进行合并，防止过多的内存碎片

## 8. 宏定义和函数有什么区别

- 宏在编译的预处理阶段完成代码的替换，运行不存在函数调用，执行更快
- 宏结构没有返回值；函数具有返回值
- 宏定义没有类型检查
- 宏定义不要添加分号，替换时会影响语义

## 9. 宏定义和 typedef 区别

- typedef 主要用于定义别名
- typedef 是编译的一部分，不会像 define 一样替换
- typedef 会进行类型检查
- 对指针的操作有一些细节上的差别，例如 typedef char * p_char 和 #define p_char char * 区别，对于语句 p_char a, b; typedef 语句相当于 char *a, *b; 而 #define 语句相当于 char *a, b;

## 10. strlen 和 sizeof 的区别

- sizeof 是运算符，并不是函数，结果在编译时并非运行时获得；strlen 是库函数，针对字符串处理。

- sizeof 参数可以是任何数据的类型或数据；strlen 参数只能是字符指针且结尾是 '\0' 的字符串

- sizeof 是编译时得到的，所以不能计算动态分配存储空间的大小，例如

  `````c++
  int* ptr = (int*)malloc(10 * sizeof(int));
  size_t size = sizeof(ptr); // 这将返回指针的大小，而不是ptr指向的内存区域的大小。
  `````

## 11. 指针常量和常量指针的区别

指针常量指向一个只读变量，变量的值不可修改，但是可以更改指针的指向，写法是 int const *p 或 const int *p

常量指针是一个不能改变指针指向的指针，写法 int *const p;

## 12. 数组的 a 和 &a 有什么区别

假设数组 int a[10]; int (*p)[10] = &a; 其中

- a 是数组名，是数组首元素地址，对 a 进行 +1 操作是取下一个数组元素
- &a 是数组的指针，类型为 int (*)[10]，对其进行 +1 操作，系统会加上整个数组的偏移

## 13. C 和 C++ 的区别

- new / delete 和 malloc / free 的区别
- 字符串类
- 输入输出库
- C++ 使用比较规范的异常处理机制代替了 C 中 setjmp() 和 longjmp()
- C++ 支持重载
- C++ 新增了引用

## 14. C++ 和 Java 的区别

- Java 完全面向对象，可以说一切皆对象，C++ 不仅支持面向对象，为了兼容 C 还支持面向过程
- Java 提供了 JVM 实现了真正意义上的跨平台，只编写一次代码，可以在任何的操作系统上运行
- Java 中没有指针的概念，减少了不安全问题
- Java 使用接口代替了抽象类的概念，在实现和维护上更容易
- Java 有自己的内存回收和分配的机制，不像 C++ 一样需要收到分配和回收

## 15. C++ 中 struct 和 class 的区别

最重要的区别其实是对成员变量和成员函数的可见性，struct 默认是 public，class 默认是 private，

## 16. C++ 中 struct 和 C 的区别

- C 语言中 struct 是用户自定义数据类型（UDT），C++ 中 struct 是抽象数据类型 （ADT），支持成员函数的定义，C++ 中的 struct 能继承，可以实现多态
- C 中 struct 是没有权限的设置的，struct 中只能是一些变量的集合体，可以封装数据但不能隐藏数据，而且成员不能是函数，当然可以是函数指针，使用函数指针的方式达到封装函数的目的

## 17. define 和 const 的区别

- define 是在编译的预处理阶段起作用，而 const 是在编译运行的时候起作用
- define 只做替换，不做类型检查和计算，也不会求解，容易产生错误，const 常量有数据类型检查
- define 只是对宏进行字符串替换，在内存中会产生多份备份，const 在程序中只有一份备份，且可以执行常亮折叠，将复杂的表达式计算出结果放入常亮表

## 18. static 和 const 的具体功能

- static
  - 不考虑类的情况下
    - 隐藏。不加 static 的函数和变量具有全局可见性，加了后只能在该文件所在的编译模块中使用
    - 默认初始化为 0，包括为初始化的全局静态变量和局部静态变量，都存储在 .bss 段
    - 静态变量在函数内定义时，始终存在，且只进行一次初始化，具有记忆性，其作用范围和局部变量相同，但是函数退出后仍然存在，再次进入作用域后，这个变量依旧保持上一次的值
  - 考虑类的情况
    - static 成员变量，属于该类而非类的实例化对象。定义时会分配空间，不能在类声明中初始化，必须在类定义体外部初始化
    - static 成员函数，不具有 this 指针，无法访问类对象的非 static 成员和非 static 成员函数；不能声明为 const、虚函数和volatile；可以被非 static 成员函数访问
- const
  - 不考虑类的情况下
    - const 常量在定义时必须初始化，之后无法更改
    - const 形参可以接收 const 和非 const 的形参
  - 考虑类的情况下
    - const 成员变量，不能在类定义外初始化，只能通过拷贝构造函数初始化成员列表初始化，且必须有构造函数；不同类对其 const 值的值可以不同
    - const 成员函数，const 对象不能调用非 const 成员函数，非 const 对象都可以调用；不可以改变非 mutable 数据的值（mutable 是为了放宽 const 成员函数的修改限制，使用场景通常是标记缓存的一些结果或调用次数的变量，这些值的改变并不改变对象对于外部的逻辑状态，只是为了加速计算或方便管理）

## 19. final 和 override 关键字

- override，声明这个函数是继承后重写的函数，编译时会确认这个函数在父类中同样声明，某种意义上是为了防止手抖敲错代码的
- final，指明某个类是不希望被继承的，某个函数是不希望被重写的

## 20. 内联函数和宏定义的区别

- 在使用时，宏定义会进行简单的字符串替换（预处理阶段），内联函数可以进行参数类型检查（编译阶段），且具有返回值
- 内联函数在编译时将函数代码嵌入到目标代码中，省去函数调用的开销，可以实现重载

## 21. 如何判断大端存储还是小端存储

- 强制转换

  `````c++
  int a = 0x1234;
  char c = (char) a;
  if (c == 0x12) {
      cout << "大端存储" << endl;
  } else if (c == 0x34) {
      cout << "小端存储" << endl;
  }
  `````
- union

  `````c++
  union Union {
      int a;
      char c;
  }
  
  int main() {
      Union un;
      un.a = 0x1234;
      if (un.c == 0x12) {
          cout << "大端存储" << endl;
      } else if (un.c == 0x34) {
          cout << "小端存储" << endl;
      }
  }
  `````

## 22. volatile、mutable 和 explicit 的用法

